# TIL

## 2023.09.27

### 프로그래머스

1. 길이가 다른 두 배열의 값을 비교할 땐 이중반복문을 사용한다.

2. 반복문 안에서 선언한 변수는, 반복문 밖에서 다시 사용할 수 없다.

3. Math 클래스의 세가지 함수 - ceil(), floor(), round()

4. 형변환: 연산이 끝나고 형변환을 하는게 아니라, 형변환을 시키고 연산을 한다.
   ex. (double)num1/num2 _1000; -> num1,num2을 double로 변환 후 (num1 / num2 _ 1000)을 함

5. 문자열을 뒤집을 땐 StringBuffer + reverse() + toString()을 이용하자. (배열 뒤집기 아님 주의)

6. 배열을 뒤집을 땐 Collection.reverse() 를 사용하자.

## 2023.09.28

1. 자바에서 배열 내용을 출력해보려고 배열 자체에서 toString()을 사용하면 배열의 내용이 아니라 배열의 주소값이 출력된다. 배열의 내용을 출력하려면 Arrays.toString()을 사용하자.

2. main 메소드 안에서 객체를 선언하면 메인 메서드 안에서만 접근할 수 있고, 메인 메소드의 실행이 끝나면 객체가 소멸된다.

3. 배열을 메서드에 전달할 때 중괄호 {}를 사용해서 배열을 리터럴로 선언하는 것은 허용되지 않는다.
   대신에 배열을 직접 생성(new)하고 값을 할당해야 한다.

4. ArrayList, LinkedList의 메소드는 거의 겹친다.

5. replace(기존문자, 바뀔문자) 를 사용하면 문자열의 특정 인덱스를 치환할 수 있다.

6. ReplaceAll 함수는 자신이 바꾸고싶은 문자로 문자열을 전부 치환시킨다.

7. String[] arr = my_string.split("")

8. 나눗셈을 할 때는 반드시 하나의 값이 실수(double)여야한다.

9. StringBuilder는 StringBuffer와 비슷한 자료형으로, 사용법도 같다. StringBuffer는 멀티 스레드 환경에서 안전하고, StringBuilder는 StringBuffer보다 성능이 우수하다. 따라서 동기화를 고려할 필요가 없는 상황에서는 StringBuffer보다 StringBuilder를 사용하는 것이 유리하다. 멀티 스레드 환경에는 StringBuffer를 쓰자.

## 2023.09.30

### 이것이 자바다

1. 함수형 프로그래밍이란 함수를 정의하고 이 함수를 데이터 처리부로 보내 데이터를 처리하는 기법이다.

2. 인터페이스의 익명 구현 객체를 람다식으로 표현하기 위해선, 인터페이스가 단 하나의 추상메소드만 가져야 한다. 그리고 인터페이스가 단 하나의 추상 메소드를 가질 때, 이를 함수형 인터페이스라고 한다.

3. 람다의 전반적인 것들을 배웠다. 익숙해지려면 많은 수련이 필요할 것이다.

### git

4.  브랜치 생성은 git branch 브랜치명
    브랜치 이동은 git switch 브랜치명
    브랜치 합치기는 main/master 브랜치로 이동한 뒤에 git merge 브랜치명
    브랜치마다 commit 내역을 그래프로 보고싶으면 git log --graph --oneline --all
    브랜치 합칠 때 conflict가 발생하면 파일열어서 수정하고 git add, git commit 하기

5.  3-way merge
    fast-forward
    rebase
    squash

### 프로그래머스

6. 메서드를 호출할 때, 메서드에 전달되는 인수(매개변수)는 변수 또는 리터럴 값으로 전달되어야 한다.

7. 메서드를 호출하더라도, 메서드를 변수에 저장(ex.a=method())하지 않으면 해당 메소드를 사용할 수 없다.

8. 나머지가 있다는 것은 곧 반올림이 가능할 수도 있다는걸 내포한다(0.5654 -> 0.6, use ceil).

9. charAt: String으로 저장된 문자열 중에서 한 글자만 선택해서 char타입으로 변환해주는 메소드이다.
   isLowerCase / isUpperCase: 소문자/대문자 여부를 확인한다.
   toLowerCase/ toUpperCase: 소문자/대문자로 변환한다.

### JavaPlayground

10. @BeforeEach: 이 어노테이션을 사용하면 각각의 테스트 메서드가 실행되기 전에 공통적인 설정 또는 초기화 작업을 수행한다.

11. isEqualTo는 값(내용)을 비교하며, 자료형이 서로 다른 경우엔 쓰지 말자.

12. ParameterizedTest: 여러 개의 테스트를 한번에 작성하기 위한 테스트

13. 주로 세트 또는 컬렉션과 단일 값 간의 동등성을 확인하려면
    `assertThat(numbers.contains(input)).isTrue();`와 같이 `contains` 메서드를 사용하는 것이 좋다. 컬렉션 자체와 단일 값 사이의 동등성 비교는 일반적으로 의미가 없으며 실패할 가능성이 높다.

14. @csvSource: csvSource를 활용하면 "중복 있는 코드"를 "중복 없는 코드"로 다시 구현할 수 있게끔 한다.

## 2023.10.02 ~ 2023.10.04

1. 스트림은 내부 반복자이다. 처리 속도가 빠르고, 람다식으로 다양한 요소를 처리할 수 있다. 또한 중간 처리와 최종 처리를 수행하도록 파이프라인을 만들 수 있다.

### TDD 연습

2. 테스트코드의 리턴타입이 꼭 void인것만은 아니다! 익숙함에 실수하지 말자.

3. while문을 사용하는 주요 이유 두가지
   a. 사용자 상호작용: 프로그램이 사용자와 상호작용(input)할 때 사용된다.
   b. 루프 탈출조건: while 루프는 특정 조건이 충족될 때까지 반복된다.

4. break 쓰는걸 까먹지 말자....

5. StringTokenizer를 사용하면 배열 안의 단어수를 세는데 편리하다. (countTokens() 사용)

6. 인스턴스 변수는 main 메소드에서 직접 접근할 수 없다. main 메소드는 정적(static) 메서드이며, 정적 메서드에서는 인스턴스 변수에 직접 접근할 수 없다.

## 2023.10.06

### TDD 연습

1. main 메소드 안에서 메소드를 만들 수 없다.

2. 에러 메시지를 출력하려면 System.err.println() 을 사용하자.

3. System.exit(1)을 입력하면 프로그램이 종료된다.

4. if문의 반대(=false)를 손쉽게 작성하려면 조건문 맨 앞에 !를 붙이면 된다.

5. count = count + 1; 을 count++;로 바꿔쓰면 가독성이 좋아진다.

6. 반복문이 반복될 때마다 ++되는 변수(ex.count)는 반복문 밖에서 선언해야한다.
   -> int count = 0;

7. 스트림에서 메소드 체이닝을 자주 쓰므로 익숙해지도록 하자

8. 중간 처리 기능인 필러링의 메소드에는 distinct(), filter()가 있다.

### 디자인

9. 추상화: 사물들의 공통된 특징을 파악해 인식의 대상으로 삼는 행위다. 추상화가 가능한 개체들은 개체가 소유한 특성의 이름으로 하나의 집합을 이룬다. 그러므로 추상화한다는 것은 여러 개체들을 집합으로 파악한다는 것과 같다.

10. 캡슐화: 캡슐화는 특히 낮은 결합도를 유지할 수 있게 해주는 객체지향 설계 원리다. 캡슐화는 정보 은닉을 통해 높은 응집도와 낮은 결합도를 갖도록 한다.

## 2023.10.11

### 우테코 연습

1. 매직 넘버를 친절한 이름의 상수로 빼주도록 하자.
2. main 메소드 안에서 클래스의 인스턴스를 생성한 후에, 인스턴스 메소드를 불러와야 한다.
3. getter는 값을 리턴하는 것이지, 출력하는 것이 아니다.
4. while 조건문과 상태라는 특성을 활용하면 숫자를 통해 프로그램을 제어하는데 편리하다.

## 2023.10.14

드디어 자소서 작성을 완성하였다! 이제 마음놓고 공부 할 수 있어서 후련하다.

### 우테코 연습

1. 비즈니스 로직, UI로직에 대해 알아보았고 블로그에 올렸다.
   나중에 코드를 작성할 때 둘을 분리해야 한다.
2. 명시적으로 생성자를 작성해 기본 생성자를 덮어쓰는 것을 잊지말자.
   초기화 로직이나 다른 설정이 없다면, 빈 생성자로 두는 것이 좋다.
3. Throwable result1: Throwable 클래스의 객체를 선언하는 것이다. Throwable은 모든 예외 클래스의 상위 클래스이므로 어떤 종류의 예외든 캐치할 수 있는 객체를 생성한다. result1 변수에 캐치된 예외를 저장할 것이다.
4. Throwable은 Java에서 모든 예외 클래스의 상위 클래스다. 따라서 Throwable 타입의 변수는 어떤 종류의 예외든 다룰 수 있는 객체를 나타낸다. 이를 통해 특정 예외 클래스에 의존하지 않고 모든 종류의 예외를 처리할 수 있다.
5. Collections.sort()를 통해 list를 오름차순 정렬할 수 있다.
6. asList와 List.of는 약간 다르다. 둘 다 불변의 리스트를 생성한다는 것은 동일하다.
   하지만 List.of는 Set으로 바꿀 수 없으며, null을 허용하지 않는다는 점에서 다르다.
   요약하자면 List.of가 더 까다로운 놈이다.

## 2023.10.15

### 우테코 연습

1. validateNumberInRange(int number, int startInclusive, int endInclusive)
   -> 검증할 숫자와 기준이 되는 두 숫자를 놓고 기준을 세워서 검증할 수 있는 메소드다.

2. 중복을 검사할 때 HashSet을 활용하면 편하다. 정규식을 사용해도 된다.

3. Enum은 보통 public으로 선언한다.

4. Enum의 생성자를 통해 값을 저장할 수 있다.

5. /\*\*

   - 구매 금액에 대한 모든 검증을 진행한다.
   - @param amount 구매 금액
   - @return 구매 금액 (int)
     \*/

   일상적으로 validation 메소드마다 파라미터 정보, 리턴 정보를 주석으로 명시하는 것 같다.

## 2023.10.16

1. 보통 View에 속하는 메소드는 public static void로 선언한다. Util도 마찬가지다. (불확실)
2. Constants, ErrorMessage는 상수이므로 public static final로 지정한다.
3. 원시값 포장은 String, int 등등 원시타입의 값을 이용해 속성을 표현하지 않고, 의미가 있는 객체로 포장하는 것이다. 줄여 말하자면 원시 타입의 변수를 객체로 포장한 것이다.
4. VO: 도메인에서 1개, 혹은 여러 개의 속성을 묶어서 특정 값을 나타내는 객체를 말한다.
5. VO의 조건1. equals & hashcode 메서드를 재정의해 동등성 비교가 가능하다.
   VO의 조건2. 불변 객체이다.

## 2023.10.16

1. 테스트 코드 작성 시 Given - When - Then 패턴을 활용하면 가독성 좋게 테스트 코드를 작성할 수 있다.

## 2023.10.20

1. Array와 ArrayList의 차이점과 특징 -> 블로그에 게시

## 2023.10.21

1. 반복문 생성 시 변수를 반복문 밖에서 선언하면 같은 변수를 n번 작업한다 -> 블로그 참고
2. 숫자야구 -> strike, ball을 0으로 초기화하는 메소드를 만드는 것을 잊지 말자.
3. boolean 변수를 활용하여, 미리 세팅을 false로 해놓은 다음, 특정 조건을 만족하는 경우 true로 바꿔서 프로그램을 종료시키는 방법이 존재한다.
4. List<String> inputList = new ArrayList<>(Arrays.asList(new String[]{"1", "2"}))
   -> 새 ArrayList를 생성하고, Arrays.asList 메서드를 사용하여 초기 요소로 "1"과 "2"를 가지는 문자열 배열을 변환하여 ArrayList에 대한 뷰를 생성한다. 이를 inputList에 저장한다.

## 2023.10.22 ~ 2023.10.30

1. 의존성 주입이란 필요한 객체를 직접 생성하거나 찾지 않고, 외부에서 넣어주는 방식이다.

2. getter 대신 Getter를 통해 얻은 상태값으로 하려고 했던 행동을 그 상태값을 가진 객체가 하도록 행동의 주체를 옮기는 방법을 사용하도록 하자.

3. setter 대신 생성자 오버로딩 or 빌더 or 정적 팩토리 메소드를 활용하자.

4. import static~ 은 사용하지 말자.

5. 출력하는 코드부분을 model 부분에서 관리해주는 것 보다, 별도의 class로 빼서 한번에 관리하면, 더욱 가독성이 좋은 코드를 만들 수 있다.

6. 변수를 인스턴스 변수로 두는 것이 나을지 혹은 지역 변수로 두는 것이 나을지 고민해보는 습관을 들이자.

## 2023.11.02

### 2주차 미션을 진행하며 배운 것들

1. 무조건 getter 사용을 지양하지는 말고, 필요에 따라 사용해도 괜찮다.

2. 원시값 포장 후 getter를 사용하는 것은 괜찮다.

3. TDD에서 Arrange - Act - Assert 패턴을 이용하면 테스트코드를 간편하게 작성할 수 있다.

4. 매직 넘버,리터럴 또한.. 무조건 상수처리 하는 것이 아니라 만약 사용자가 단번에 이해할 수 있다면 굳이 처리하지 않아도 괜찮다.

5. 주어진 요구조건이 "내부의 속성을 밖으로 꺼내는 것"이므로 이미 요구사항이 은닉하지 말것을 요구하고 있다.
   따라서 getter의 사용은 필연적이다.
   또한 이미 요구사항이 "은닉하지 말것을 요구"하므로 getter의 사용으로 인해 캡슐화가 깨어졌다고 할 수는 없다.

## 2023.11.21

## 3주차 미션을 진행하며 배운 것들

1. 중첩 클래스 사용 시, 거의 모든 경우에 inner class에 static을 붙이는 것이 좋다.

2. 외부에서 이미 생성된 객체(Name,Move) 를 생성자에서 받아 Car 객체를 초기화할 수도 있고, 아니면 String 타입의 CarName을 받아서 Name, Move 객체를 내부에서 생성하고 초기화할 수 있다.

3. 모든 검증을 Validation 관련 클래스에 넣을 필요는 없다.

4. InputView에서 출력(sysout)을 하지말고, OutputView가 출력을 담당하도록 하자.

5. View는 최대한 출력만 담당하도록 구조를 수정하면 모듈화가 향상될 것이다. 하지만 간단한 데이터 검증 및 변환 정도는 뷰에서 사용해도 좋다.

6. 생성자에서 검증하는 방법을 적극 활용해보자.

7. 불변 리스트: 수정을 방지하는 불변 리스트라는 것이 있다. Collections.unmodifiableList() 또는 List.copyOf()를 사용하여 만들 수 있는데, 전자는 원본 객체와의 참조가 끊어지지 않아 원본 리스트의 수정은 막지 못한다.

8. 컨트롤러는 비즈니스 로직을 알 필요가 없으며, 컨트롤러는 가능한 도메인 논리에 대해 가벼워야 한다.

9. public 메소드만 테스트해라. private 메소드를 꼭 테스트 해야 하는 상황이 온다면
   그건 높은 확률로 설계가 잘못 되었을 가능성이 높다.

10. 출력은 도메인 밖에서 하는 것이 좋다.

11. 매개변수에 final을 적용하는 것을 "매개변수의 불변성"이라고 한다. final 키워드를 사용하면 해당 매개변수는 메서드 내에서 값을 변경할 수 없게 된다.

12. 변수 이름에 자료형을 사용하지 말기 (ex.lottoList)

13. 메소드명은 15자 이하로 작성하기

## 2023.11.21

## 4주차 미션을 진행하며 배운 것들

1. 열거형 클래스는 toString() 메소드를 명시적으로 정의하지 않아도 enum 상수의 이름(name)을 문자열로 반환하는 기본 toString() 메소드를 제공한다.

2. 멤버 변수를 생성하는 부분에서, 각 객체를 재할당 할 필요가 없다면 불변성을 위해 final로 선언하는 것이 좋다.

3. 매개변수가 많으면 결합도 증가, 인터페이스 변경의 어려움, 가독성 감소의 단점이 생긴다.

4. 메소드를 또다른 메소드로 감싸는 것에는 장단점이 존재한다.
   장점: 가독성 향상 + 만약 감싼 메소드가 여러 곳에서 사용된다면, 해당 동작을 감싼 메소드를 만들어 코드의 중복을 피할 수 있다. 만약 추후에 동작이 변경되어야 할 때, 해당 변경은 한 곳에서만 이루어지면 된다.
   단점: 감싸는 메소드가 불필요하게 많아지면 코드가 더 복잡해질 수 있으므로 무의미한 래핑은 피해야 한다.

5. 로직의 처리와 출력 기능을 같은 메소드로 묶지 않는 것이 좋다.

6. while(true)를 사용하면 코드를 유지보수 하는 과정에서 무한루프에 빠질 가능성이 존재한다. 따라서 재귀함수나 do-while을 사용하도록 하자.

## 2023.11.24

## 스터디(숫자야구)

1. 강박적으로 모든 경우에 방법론을 적용할 필요는 없다. 오히려 가독성을 해치고 메모리양만 늘어나는 경우가 생길 수 있다.

2. 모든 상수를 상수 클래스에 등록할 필요는 없다. 특정 클래스에 종속적인 상수라면, 특정 클래스 안에서 상수를 선언하는 것도 괜찮다.

3. 공통적인 검증은 Validation 클래스에 넣고, 특정 클래스에만 적용되는 검증이면 해당 클래스에 검증메소드를 넣자.

4. while(true)는 유지보수에 좋지 않다. 재귀함수는 함수 stack이 계속 쌓여서 메모리가 낭비된다. 따라서 do-while을 애용하자.

5. 파생되어 나오는 값은 필드로 지정할 필요가 없다. 단, 다른 메소드나 클래스에서 사용되면 필드로 지정해라.

6. 조건문 내부에 논리연산자를 사용하면서까지 depth를 1로 만들 필요는 없다. 차라리 if(조건1) + if(조건2) 와 같이 이중 if문을 사용해보자.

7. do-while문은 while문이 true일 동안 반복문이 실행된다.

8. 예를 들어 List<Integer> randomNumbers = new ArrayList<>(); 와 같은 코드에서 우항을 작성하지 않으면 객체가 생성되지 않으므로 난수가 리스트에 들어가지 않는 문제가 발생한다. 따라서 꼭 객체생성하는 부분을 작성하자.

9. 두 개 이상의 인자를 전달할 때는, 객체로 만들어서 전달하면 된다. (ex. ballCount, strikeCount -> BallStrikeCount 클래스)

10. 게임 재시작 시 새로운 난수를 생성하게 하려면 리스트를 새로 초기화하는 기능을 추가하면 된다.

## 2023.11.26

1. 다른 클래스에서 함수를 사용할 때는 [class명].[함수명]으로 사용하시는 게 가독성이 좋다. 그렇게 하지 않으면 사용자가 해당 클래스에 있는 있는 함수로 인식하게 된다.

2. 객체를 많이 만들 필요가 전혀 없다. 하는 일이 별로 없으면 굳이 만들 필요가 없다.

3. 검증이 잘 작동하지 않으면 로직을 구체적으로 작성해보아라.
   true를 리턴하는 로직 대신 false를 리턴하는 로직으로 써본다던가..

4. List<Car> cars 라는 개념을 기억하자. 각각의 자동차를 Car 객체로 선언하고, 그것들을 포함하는 리스트 cars를 선언하는 것이다. 로또 미션에서 List<Lotto> LottoNumbers와 같은 개념이다.

5. Car 클래스에 필드로 name, price가 있다면 각각의 Car는 name과 price를 필드로 갖는다.

6. 레이싱게임에서 우승자의 타입은 무엇일까? String이 절대 아니다. 우승자는 Cars 중에 하나일 것이기 때문에 List<Cars> 이다!!

7. 입력값이 영어인지 검증하려면, Pattern.matches(패턴, 검사 대상); 을 통해 영어만으로 이루어져있는지 검사할 수 있다.

8. repeat()을 쓸 때는 (Math.max(0, 대상)) 과 함께 쓰자.

9. Enum은 기본적으로 모든 열거 상수가 동일한 타입을 가져야 한다.

## 2023.11.27

1. 파라미터의 개수가 많고, Controller, Service처럼 전체 프로젝트에서 구현체가 주로 하나만 사용된다면 IoC Container를, 파라미터의 개수가 많고, 파라미터에 들어가는 값이 매번 달라지는 Model은 Builder 패턴을 사용하자.

2. 의존관계 역전 원칙: 의존성 역전 원칙이란 객체는 구체적인 객체가 아닌 추상화에 의존해야 한다. 또한 의존관계를 맺을 때 자신보다 변화하기 쉬운 것을 의존해서는 안되고, 거의 변화가 없는 개념에 의존해야 한다. 예를 들면, 아이가 장난감을 갖고 노는데 어떤 경우에는 로봇을, 어떤 경우에는 레고를 가지고 놀 것이다. 이 경우에서 변하기 쉬운 것은 로봇, 레고, 모형 자동차다. 하지만 아이가 장난감을 가지고 논다는 사실은 변하기 어려운 개념이다.

3. 객체에서 의존하는 다른 객체가 너무 많아지는 문제를 IoC 컨테이너로 해결할 수 있다.

4. IoC(Inversion of Control; 제어의 역전): IoC는 소프트웨어 개발 디자인 원칙 중 하나로, 객체의 의존성 관리를 외부에서 하도록 한다. DI는 IoC를 지키는 방법 중 하나이다.

## 23.12.04

## 스터디(크리스마스)

1. 해당 월의 말일을 구할 땐, Calender 클래스의 cal.getActualMaximum(Calendar.DAY_OF_MONTH) 를 활용하면 된다. 단 월에는 -1을 해주어야 한다.

2. 도메인에서 모든 출력문구를 보내는 방법이 더 깔끔할 수도 있다.

3. if문을 두번 쓰지않고 첫번째 if문에 return;을 작성하면 두번째 if문을 쓸 필요가 없다.

4. Numberformat보다는 %d를 활용하면 간편하게 콤마를 숫자에 넣을 수 있다.

5. 객체를 만들면서 에러가 발생하는 경우에는 테스트코드 작성은 하지 않아도 된다.

6. 공백 포함여부를 검증하기 위해선 input.contains(" "), input == null 을 입력하면 된다.
   contains.null 은 불가능하므로 == null로 작성해야만 한다.
   그리고 입력값의 첫번째 값이 "0"인지 검사하기 위해선 startsWith()를 사용하면 된다.

7. 소수점 관련 계산을 할 땐 BigDecimal을 활용하자.

## 23.12.28

## 네트워크 기초

1. 네트워크의 종류는 크기와 연결 형태로 나눌 수 있다. 종류는 여러가지지만 필수만 작성하겠다.
   크기: LAN, WAN
   연결 형태: Star, Mesh

2. 네트워크의 통신방식
   유니 캐스트: 특정 대상이랑만 1대1로 통신하는 방식
   멀티 캐스트: 특정한 다수와 통신하는 방식
   브로드 캐스트: 같은 네트워크에 있는 모든 사용자와 통신하는 방식

3. 사용하고자 하는 기능에 따라 필요한 프로토콜이 달라진다.

4. 프로토콜은 하나만 사용되지는 않고 주로 함께 사용된다. Ethernet, IPv4, TCP, 데이터의 묶음을 패킷이라고 한다.

5. cmd에서 tracert(트레이스 라우팅) 명령어를 통해 지정된 IP 주소로의 경로 추적(Traceroute) 결과를 표시한다.
   이 명령을 실행하면 목적지 IP 주소로 가는 경로에 있는 네트워크 장치들과 데이터 패킷의 왕복 시간을 확인할 수 있다.
